#!/usr/bin/env python3
#----------------------------------------------------------------------------
# Created By  : Armando Ameri'
# Created Date: 2023/02/06
# e-mail:       armando.ameri@studio.unibo.it
# version ='1.0'
# ---------------------------------------------------------------------------
# -*- coding: utf-8 -*-
"""

This module allow to import a csv file generated by the shell command 'rostopic 
echo -p /datas3 > ~/Escritorio/armband_ws/src/ros_gforce/csv/0_Armando.csv' when
the 'emg_signal_processing_full_channel_notch_high_maslide.py' node is running
(for further informations see annex).

Example:
    Examples can be given using either the ``Example`` or ``Examples``
    sections. Sections support any reStructuredText formatting, including
    literal blocks::

        $ python example_google.py

Section breaks are created by resuming unindented text. Section breaks
are also implicitly created anytime a new section starts.

Attributes:
    module_level_variable1 (int): Module level variables may be documented in
        either the ``Attributes`` section of the module docstring, or in an
        inline docstring immediately following the variable.

        Either form is acceptable, but the two should not be mixed. Choose
        one convention to document module level variables and be consistent
        with it.

Todo:
    * For module TODOs
    * You have to also use ``sphinx.ext.todo`` extension

.. _Google Python Style Guide:
   http://google.github.io/styleguide/pyguide.html

"""

import pandas as pd
import numpy as np
from nmf import NMF
import yaml
from sklearn.decomposition import NMF
import matplotlib.pyplot as plt
from matplotlib.widgets import Cursor
import math
import sys

######################
### YAML functions ###
######################

def yaml_loader(filepath):          # Loads a yaml file
     with open(filepath, 'r') as file_descriptor:
          data = yaml.load(file_descriptor)
     return data

def yaml_dump(filepath, data):      # Dumps data to a yaml file
      with open(filepath, 'w') as file_descriptor:
          yaml.dump(data, file_descriptor)

#########################
### CSV & YAML import ###
#########################

# filepath = "range.yaml" # name of yaml file generated with import_file_x_plot.py -> num_name
yaml_imp_file = sys.argv[1] + '_range'
print("Importing yaml -> " + yaml_imp_file + '.yaml')
# yaml_path = '~/Escritorio/armband_ws/src/ros_gforce/yaml/' + yaml_imp_file + '.yaml'
yaml_imp_path = '/home/110682@TRI.LAN/Escritorio/armband_ws/src/ros_gforce/config/' + yaml_imp_file + '.yaml'
with open(yaml_imp_path, 'r') as file_descriptor:
    w_range = yaml.load(file_descriptor)
print(len(w_range))


csv_name = sys.argv[1] # Format -> num_name -> 0_Armando
print("Opening csv -> " + csv_name + '.csv')
# csv_path = '~/Escritorio/armband_ws/' + csv_name + '.csv'
csv_path = '~/Escritorio/armband_ws/src/ros_gforce/csv/' + csv_name + '.csv'
data = pd.read_csv(csv_path)
df = pd.DataFrame(data)
# print(df)

time = df["%time"]
ch0 = df["field.data0"]
ch1 = df["field.data1"]
ch2 = df["field.data2"]
ch3 = df["field.data3"]
ch4 = df["field.data4"]
ch5 = df["field.data5"]
ch6 = df["field.data6"]
ch7 = df["field.data7"]
print("time: ", len(time))



###############################
### Parameters' computation ###
###############################

print("Range definition...")
windows = [w_range["window_range"]]
print(len(windows))
print(windows)
diff_range = windows[0][1] - windows[0][0]
diff_range_2 = windows[0][3] - windows[0][2]

print("diff_range: ", diff_range)
print("diff_range_2: ", diff_range_2)
prova = []

for t in time:
    prova.append(int(str(t)[0:13]))
print("prova: ", len(prova))
# print(prova)
# windows_index = [[prova.index(windows[0][0])],[prova.index(windows[0][1])]]

# diff_range_index = windows_index[0][1] - windows_index[0][0]
diff_range_index = diff_range
print(type(diff_range_index))
print("diff_range: ", diff_range_index)

(c,r) = df.transpose().shape
A = np.zeros((8,int(diff_range_index)))
print("A.shape: ",A.shape)

A[0][:] = ch0[int(windows[0][0]):int(windows[0][1])].transpose()
A[1][:] = ch1[int(windows[0][0]):int(windows[0][1])].transpose()
A[2][:] = ch2[int(windows[0][0]):int(windows[0][1])].transpose()
A[3][:] = ch3[int(windows[0][0]):int(windows[0][1])].transpose()
A[4][:] = ch4[int(windows[0][0]):int(windows[0][1])].transpose()
A[5][:] = ch5[int(windows[0][0]):int(windows[0][1])].transpose()
A[6][:] = ch6[int(windows[0][0]):int(windows[0][1])].transpose()
A[7][:] = ch7[int(windows[0][0]):int(windows[0][1])].transpose()

time_t = np.arange(0, r, 1, dtype=int)

print("Computation nnmf...")
# M, U_Offline, info = NMF().run(A[:,windows_index[0][0]:windows_index[1][0]], 2)
model = NMF(n_components=2, init='random', max_iter = 1000, random_state=0)
M = model.fit_transform(A)
U_Offline = model.components_

print(M)
print("M: ", M.shape)

U_Offline_T = U_Offline.transpose()
print(U_Offline_T)
print("U_Offline_T.type: ",type(U_Offline_T))
print("U_Offline_T.shape: ",U_Offline_T.shape)
plt.figure()
plt.suptitle('U')
plt.plot(time_t[int(windows[0][0]):int(windows[0][1])], U_Offline_T)
# plt.show()

for i in range(U_Offline_T.shape[0]):
    if U_Offline_T[i,0] < 0 or  U_Offline_T[i,1] < 0:
        print("vattene")
    # else:
    #     print("no valori negativi")

print("Computation M pinv...")

M_pinv = np.linalg.pinv(M)
print(M_pinv.tolist())
print("M_pinv: ", M_pinv.shape)

print("Defining vectors...")
u_ext = U_Offline_T[:,0]
u_flex = U_Offline_T[:,1]
print(u_ext)
print(U_Offline_T[0][0])
print(U_Offline_T[0][1])
print(U_Offline_T)
print(U_Offline_T[:,0])



k_ext =  np.sum(u_ext) / diff_range_2
k_flex = np.sum(u_flex) / diff_range_2


print("np.sum(u_ext)", np.sum(u_ext))
print("np.sum(u_flex)", np.sum(u_flex))
print(type(k_ext))
print(k_ext)
k_ext = float(k_ext)
k_flex = float(k_flex)
print(type(k_flex))
print(k_flex)

mat_mult = np.matmul(M_pinv, A)
print("mat_mult.shape: ", mat_mult.shape)
print("mat_mult.type: ", type(mat_mult))

# plt.figure(3)
# plt.suptitle('mat_mult')
# plt.plot(time_t[int(windows[0][0]):int(windows[0][1])], mat_mult[0,:])
# plt.plot(time_t[int(windows[0][0]):int(windows[0][1])], mat_mult[1,:])
# plt.show()

a = np.array([np.divide(mat_mult[0,:],k_ext), np.divide(mat_mult[1,:],k_flex)])
print("a.shape: ", a.shape)

# plt.figure(4)
# plt.suptitle('a')
# plt.plot(time_t[int(windows[0][0]):int(windows[0][1])], a[0,:])
# plt.plot(time_t[int(windows[0][0]):int(windows[0][1])], a[1,:])
# plt.show()

a = a.transpose()
print("a.shape: ", a.shape)
print("a: ", a)
print("min: ", np.minimum(a[:,0],a[:,1]))

# cc_level_min = float(a.min())
# cc_level_max = float(a.max())

# plt.figure(5)
# plt.suptitle('cc_level')
# plt.plot(time_t[int(windows[0][0]):int(windows[0][1])], np.minimum(a[:,0],a[:,1]))
# plt.show()


cc_level_min = np.minimum(a[:,0],a[:,1])
# j = 0
# for i in cc_level_min:
#     if i < 0 :
#         cc_level_min[j] = 0
#     j = j +1

# print(min(cc_level_min))

##################
### YAML Write ###
##################

# write_range = { 'window_range' : diff_range_index}
write_k = {"k_ext": k_ext, "k_flex": k_flex}
# write_cc = {"cc_level_min": cc_level_min}
res = {idx + 1 : M_pinv.tolist()[idx] for idx in range(len(M_pinv.tolist()))}

# filepath = "test1.yaml"
yaml_exp_file = sys.argv[1] + '_matrix'
# with open(filepath, "w") as f:
    # yaml_dump(filepath, res)
    # outputs = yaml.dump(res, filepath)

yaml_exp_path = '/home/110682@TRI.LAN/Escritorio/armband_ws/src/ros_gforce/config/' + yaml_exp_file + '.yaml'
print("writing yaml on -> " + yaml_exp_path)

with open(yaml_exp_path, 'w') as file_descriptor:
    yaml.dump(write_k, file_descriptor)
    # yaml.dump(write_cc, file_descriptor)
    yaml.dump(res, file_descriptor)


# asd = []

# for i in x1:
#     asd = np.append(asd,math.trunc(i))

# print(type(asd))

# write_range = { 'window_range' : asd.tolist()}
# print(write_range)
# print(type(write_range))

# with open(yaml_exp_file, 'w') as file_descriptor:
#     # yaml.dump(write_range, file_descriptor)
#     yaml.dump(write_k, file_descriptor)
#     yaml.dump(write_cc, file_descriptor)
#     yaml.dump(res, file_descriptor)